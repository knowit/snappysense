/* -*- fill-column: 100; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* SnappySense firmware code based on the ESP32-IDF + FreeRTOS framework only (no Arduino). */

#include <inttypes.h>
#include <stdio.h>
#include <sys/time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

#include "main.h"
#include "device.h"
#include "piezo.h"

/* Generated by the music-compiler program (see repo root) */
/* StarWars */
const struct tone notes_5577006791947779410[] = {{1109,197},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,1183},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,789},{440,1578},};
const struct music melody = { 40, notes_5577006791947779410 };

static QueueHandle_t gpio_evt_queue = NULL;

static void clock_callback(TimerHandle_t t) {
  uint32_t ev = EV_CLOCK;
  xQueueSend(gpio_evt_queue, &ev, 0);
}

void app_main(void)
{
  /* Bring the power line up and wait until it stabilizes */
  power_up_peripherals();

  /* Queue of events from monitoring tasks and ISRs to the main task */
  gpio_evt_queue = xQueueCreate(10, sizeof(uint32_t));

  /* Events are communicated by the ISR on the event queue */
  install_interrupts(gpio_evt_queue);

  /* Initialize peripherals */

#ifdef SNAPPY_GPIO_SEN0171
  initialize_gipo_sen0171();
#endif

#ifdef SNAPPY_I2C
  initialize_i2c();
#endif

#ifdef SNAPPY_I2C_SEN0500
  initialize_i2c_sen0500();
#endif

  /* TODO: SNAPPY_ADC_SEN0487 microphone */
  /* TODO: SNAPPY_I2C_SEN0514 air/gas sensor */

#ifdef SNAPPY_I2C_SSD1306
  initialize_i2c_ssd1306();
#endif

  /* Create a clock tick used to drive device readings */
  TimerHandle_t t = xTimerCreate("sensor-clock", pdMS_TO_TICKS(15*1000), pdTRUE, NULL, clock_callback);
  xTimerStart(t, 0);

  /* And we are up! */
  LOG("Snappysense running!\n");
  show_text("Hello, world!");
  play_song(&melody);

  /* Process events forever */
  struct timeval button_down; /* Time of button press */
  bool was_pressed = false;   /*   if this is true */
  for(;;) {
    uint32_t ev;
    if(xQueueReceive(gpio_evt_queue, &ev, portMAX_DELAY)) {
      switch (ev & 15) {
      case EV_PIR:
	LOG("PIR: %" PRIu32 "\n", ev >> 4);
	break;
      case EV_BTN1: {
	/* Experimentation suggests that it's possible to have spurious button presses of around 10K
	   us, when the finger nail sort of touches the edge of the button and slides off.  A "real"
	   press lasts at least 100K us. */
	uint32_t state = ev >> 4;
	LOG("BUTTON: %" PRIu32 "\n", state);
	if (!state && was_pressed) {
	  struct timeval now;
	  gettimeofday(&now, NULL);
	  uint64_t t = ((uint64_t)now.tv_sec * 1000000 + (uint64_t)now.tv_usec) -
	    ((uint64_t)button_down.tv_sec * 1000000 + (uint64_t)button_down.tv_usec);
	  LOG("  Pressed for %" PRIu64 "us\n", t);
	}
	was_pressed = state == 1;
	if (state) {
	  gettimeofday(&button_down, NULL);
	}
	break;
      }
      case EV_CLOCK: {
	LOG("CLOCK\n");
	float temp = 0.0f;
	if (read_temperature(&temp)) {
	  show_text("Temperature: %.1f", temp);
	  LOG("  Temperature = %.2f\n", temp);
	} else {
	  LOG("  Failed to read temperature.\n");
	}
	break;
      }
      default:
	LOG("Unknown event: %" PRIu32 "\n", ev);
	break;
      }
    }
  }
}

void panic(const char* msg) {
  LOG("PANIC: %s\n", msg);
  for(;;) {}
}

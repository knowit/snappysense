/* -*- fill-column: 100; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* SnappySense firmware code based on the ESP32-IDF + FreeRTOS framework only (no Arduino). */

#include <inttypes.h>
#include <stdio.h>
#include <sys/time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

#include "main.h"
#include "device.h"
#include "piezo.h"

#define MONITORING_WINDOW_S 10
#define MONITORING_INTERVAL_S 15
#define NEXT_SLIDE_INTERVAL_S 4

/* Generated by the music-compiler program (see repo root) */
/* StarWars */
const struct tone notes_5577006791947779410[] = {{1109,197},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,1183},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,789},{440,1578},};
const struct music melody = { 40, notes_5577006791947779410 };

/* Queues and clocks */
static QueueHandle_t evt_queue = NULL;
static TimerHandle_t sensor_clock = NULL;
static TimerHandle_t slideshow_clock = NULL;
static TimerHandle_t monitoring_clock = NULL;

/* Sensor state */
static bool have_temperature = false;
static float temperature;
static bool have_humidity = false;
static float humidity;
static bool motion = false;

static void clock_callback(TimerHandle_t t) {
  uint32_t ev = EV_NONE;
  if (t == sensor_clock) {
    ev = EV_SENSOR_CLOCK;
  } else if (t == slideshow_clock) {
    ev = EV_SLIDESHOW_CLOCK;
  } else if (t == monitoring_clock) {
    ev = EV_MONITORING_CLOCK;
  }
  xQueueSend(evt_queue, &ev, portMAX_DELAY);
}

#ifdef SNAPPY_I2C_SSD1306
void show_text(const char* fmt, ...) {
  if (!ssd1306) {
    return;
  }
  va_list args;
  va_start(args, fmt);
  char buf[32*4];		/* Largest useful string for this screen and font */
  vsnprintf(buf, sizeof(buf), fmt, args);
  va_end(args);
  ssd1306_Fill(ssd1306, SSD1306_BLACK);
  ssd1306_SetCursor(ssd1306, 0, 0);
  ssd1306_WriteString(ssd1306, buf, Font_7x10, SSD1306_WHITE);
  ssd1306_UpdateScreen(ssd1306);
}
#else
void show_text(const char* fmt, ...) {}
#endif

void app_main(void)
{
  /* Bring the power line up and wait until it stabilizes */
  power_up_peripherals();

  /* Queue of events from monitoring tasks and ISRs to the main task */
  evt_queue = xQueueCreate(10, sizeof(uint32_t));

  /* Events are communicated by the ISR on the event queue */
  install_interrupts(evt_queue);

  /* Initialize peripherals */

  install_buttons();

#ifdef SNAPPY_GPIO_SEN0171
  initialize_gpio_sen0171();
#endif

#ifdef SNAPPY_I2C
  initialize_i2c();
#endif

#ifdef SNAPPY_I2C_SEN0500
  initialize_i2c_sen0500();
#endif

  /* TODO: SNAPPY_ADC_SEN0487 microphone */
  /* TODO: SNAPPY_I2C_SEN0514 air/gas sensor */

#ifdef SNAPPY_I2C_SSD1306
  initialize_i2c_ssd1306();
#endif

  /* Create a clock tick used to drive device readings */
  /* TODO: Should we have this instead separate windows by this interval and not
     just blindly start new monitoring this often? */
  sensor_clock = xTimerCreate("sensor", pdMS_TO_TICKS(MONITORING_INTERVAL_S*1000),
                              /* restart= */ pdTRUE,
                              NULL, clock_callback);
  xTimerStart(sensor_clock, portMAX_DELAY);

  /* This one-shot timer is started when the monitoring window opens and signals the
     close of the window. */
  monitoring_clock = xTimerCreate("monitor", pdMS_TO_TICKS(MONITORING_WINDOW_S*1000),
                                  /* restart= */ pdFALSE,
                                  NULL, clock_callback);

#ifdef SNAPPY_I2C_SSD1306
  /* Create a clock tick used to drive the slideshow, independent of monitoring. */
  if (ssd1306) {
    slideshow_clock = xTimerCreate("slideshow", pdMS_TO_TICKS(NEXT_SLIDE_INTERVAL_S*1000),
                                   /* restart= */ pdTRUE,
                                   NULL, clock_callback);
    xTimerStart(slideshow_clock, portMAX_DELAY);
  }
#endif

  /* And we are up! */
  LOG("Snappysense running!\n");
  show_text("Hello, world!");
  //  play_song(&melody);

  /* Process events forever */
  struct timeval button_down; /* Time of button press */
  bool was_pressed = false;   /*   if this is true */

  int slideshow_next = 0;
  for(;;) {
    uint32_t ev;
    if(xQueueReceive(evt_queue, &ev, portMAX_DELAY)) {
      switch (ev & 15) {
      case EV_PIR:
        LOG("Motion!\n");
        motion = true;
	break;

      case EV_BTN1: {
	/* Experimentation suggests that it's possible to have spurious button presses of around 10K
	   us, when the finger nail sort of touches the edge of the button and slides off.  A "real"
	   press lasts at least 100K us. */
	uint32_t state = ev >> 4;
	LOG("BUTTON: %" PRIu32 "\n", state);
	if (!state && was_pressed) {
	  struct timeval now;
	  gettimeofday(&now, NULL);
	  uint64_t t = ((uint64_t)now.tv_sec * 1000000 + (uint64_t)now.tv_usec) -
	    ((uint64_t)button_down.tv_sec * 1000000 + (uint64_t)button_down.tv_usec);
	  LOG("  Pressed for %" PRIu64 "us\n", t);
	}
	was_pressed = state == 1;
	if (state) {
	  gettimeofday(&button_down, NULL);
	}
	break;
      }

      case EV_SENSOR_CLOCK: {
        LOG("Monitoring window opens\n");
#ifdef SNAPPY_I2C_SEN0500
        /* Environment sensor.  These we read instantaneously.  It might make sense to read multiple
         * times and average or otherwise integrate; TBD.
         */
        have_temperature =
          have_sen0500 &&
          dfrobot_sen0500_get_temperature(&sen0500, DFROBOT_SEN0500_TEMP_C, &temperature) &&
          temperature != -45.0;
        if (have_temperature) {
          LOG("Temperature = %.2f\n", temperature);
        }
        have_humidity =
          have_sen0500 &&
          dfrobot_sen0500_get_humidity(&sen0500, &humidity) &&
          humidity != 0.0;
        if (have_humidity) {
          LOG("Humidity = %.2f\n", humidity);
        }
        /* And more! */
#endif
#ifdef SNAPPY_GPIO_SEN0171
        /* Motion sensor.  We enable the interrupt for the PIR; then PIR interrupts will simply be
           recorded.  At the end-of-montoring window we just disable the interrupt again */
        motion = false;
        enable_gpio_sen0171();
#endif
        xTimerStart(monitoring_clock, portMAX_DELAY);
        break;
      }

      case EV_MONITORING_CLOCK:
#ifdef SNAPPY_GPIO_SEN0171
        disable_gpio_sen0171();
#endif
        LOG("Monitoring window closed\n");
        break;

      case EV_SLIDESHOW_CLOCK:
        /* TODO: Splash screen */
        /* TODO: For the text display, use bitmaps *or* use a larger font and
           center the text and place the text on two lines, caption above
           and reading + units below */
        switch (slideshow_next) {
        case 0:
          slideshow_next++;
          if (have_temperature) {
            show_text("Temp: %.1f C", temperature);
            break;
          }
          /* FALLTHROUGH */
        case 1:
          slideshow_next++;
          if (have_humidity) {
            show_text("Humidity: %.1f %%", humidity);
            break;
          }
          /* FALLTHROUGH */
        case 2:
          slideshow_next++;
#ifdef SNAPPY_GPIO_SEN0171
          show_text("Motion: %s", motion ? "Yes" : "No");
          break;
#else
          /* FALLTHROUGH */
#endif
        default:
          slideshow_next = 0;
          break;
        }
        break;
      default:
	LOG("Unknown event: %" PRIu32 "\n", ev);
	break;
      }
    } else {
      /* WHAT TO DO HERE?  We timed out or there was some bizarre error? */
    }
  }
}

void panic(const char* msg) {
  LOG("PANIC: %s\n", msg);
  for(;;) {}
}

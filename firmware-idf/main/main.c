/* -*- fill-column: 100; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* SnappySense firmware code based on the ESP32-IDF + FreeRTOS framework only (no Arduino). */

#include "main.h"

#include <inttypes.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

#include "device.h"
#include "sound_player.h"
#include "sound_sampler.h"
#include "oled.h"
#include "sensor.h"

/* Parameters */
#define NEXT_SLIDE_INTERVAL_S 4

/* Generated by the music-compiler program (see repo root) */
/* StarWars */
const struct tone notes_5577006791947779410[] = {{1109,197},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,1183},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,789},{440,1578},};
const struct music melody = { 40, notes_5577006791947779410 };

/* The global event queue for the main loop */
QueueHandle_t/*<snappy_event_t>*/ snappy_event_queue = NULL;

/* Clocks used by the main loop */
static TimerHandle_t slideshow_clock = NULL;

static void slideshow_clock_callback(TimerHandle_t t) {
  uint32_t ev = EV_SLIDESHOW_CLOCK;
  xQueueSend(snappy_event_queue, &ev, portMAX_DELAY);
}

/* Slideshow state */
static int slideshow_next = 0;
static bool show_debug = false;

static void advance_slideshow();
static void handle_button(uint32_t state);
static void panic(const char* msg) __attribute__ ((noreturn));

void app_main(void)
{
  /*******************************************************************************
   *
   * Boot level 1: Devices that must work */

  /* Bring the power line up and wait until it stabilizes */
  power_up_peripherals();

  /* Set up interrupts and event queueing. */
  snappy_event_queue = xQueueCreate(10, sizeof(snappy_event_t));
  install_interrupts();

  /* Peripherals */

  /* Set up buttons but do not make them send events yet */
  initialize_onboard_buttons();

#ifdef SNAPPY_I2C
  if (!initialize_i2c()) {
    panic("i2c system inoperable; nothing will work");
  }
#endif

#ifdef SNAPPY_I2C_SSD1306
  /* Display */
  if (!initialize_i2c_ssd1306()) {
    LOG("OLED device inoperable");
  }
#endif
#ifdef SNAPPY_OLED
  oled_clear_screen();
#endif

  /* We're far enough along that we can talk to the screen */
  LOG("Snappysense active!");
#ifdef SNAPPY_OLED
  oled_show_text("SnappySense v1.1\nKnowIt ObjectNet\n2023-02-07 / IDF");
#endif

  /*******************************************************************************
   *
   * Boot level 2: Sensor devices, these can be absent */

#ifdef SNAPPY_GPIO_SEN0171
  /* Movement sensor */
  if (!initialize_gpio_sen0171()) {
    LOG("Movement device inoperable");
  }
#endif

#ifdef SNAPPY_ADC_SEN0487
  /* Sound sensor */
  if (!initialize_adc_sen0487()) {
    LOG("Sound device inoperable");
  }
#endif

#ifdef SNAPPY_I2C_SEN0500
  /* Environment sensor */
  if (!initialize_i2c_sen0500()) {
    LOG("Environment device inoperable");
  }
#endif

#ifdef SNAPPY_I2C_SEN0514
  /* Air/gas sensor */
  if (!initialize_i2c_sen0514()) {
    LOG("Air/gas device inoperable");
  }
#endif

#ifdef SNAPPY_GPIO_PIEZO
  if (!initialize_gpio_piezo()) {
    LOG("Piezo device inoperable");
  }
#endif

  /*******************************************************************************
   *
   * Boot level 3: helper tasks and clocks.
   *
   * TODO: Clock creation must not fail, check that. */

#ifdef SNAPPY_READ_NOISE
  if (!sound_sampler_begin()) {
    LOG("Unable to initialize the sampler task");
  }
#endif
#ifdef SNAPPY_SOUND_EFFECTS
  if (!sound_effects_begin()) {
    LOG("Unable to initialize the sound player task");
  }
#endif

  /* TODO: Check that this succeeds; otherwise we're sunk */
  sensor_begin();

#ifdef SNAPPY_OLED
  if (oled_present()) {
    /* Create a clock tick used to drive the slideshow, independent of monitoring. */
    slideshow_clock = xTimerCreate("slideshow", pdMS_TO_TICKS(NEXT_SLIDE_INTERVAL_S*1000),
                                   /* restart= */ pdTRUE,
                                   NULL, slideshow_clock_callback);
    xTimerStart(slideshow_clock, portMAX_DELAY);
  }
#endif

  /* Buttons will now send events */
  enable_onboard_buttons();

  /* And we are up! */
  LOG("Snappysense running!");
  //  play_song(&melody);

  /* Process events forever.

     This is mainly a state machine with a cycle of sleep-monitoring-reporting-sleep-... states.
     Within the monitoring and reporting states there may be minor cycles.  Right now the machine is
     driven by a clock that starts the monitoring state and there is no reporting state, but this
     will change.
   
     Overlapping that state machine is one that drives the slide show, if enabled.  The two state
     machines are independent but are handled by the same switch for practical reasons.  Thus some
     display work can happen during monitoring, but this should not adversely affect anything.
   
     Finally, some events can interrupt the state machine.  PIR interrupts are seen during
     monitoring and are simply recorded.  Button interrupts are seen anytime and are currently
     ignored but may cause the device operation to change. */

  for(;;) {
    uint32_t ev;
    if(xQueueReceive(snappy_event_queue, &ev, portMAX_DELAY)) {
      switch (ev & 15) {
#ifdef SNAPPY_READ_MOTION
      case EV_MOTION:
        record_motion();
	break;
#endif

      case EV_BTN1:
        handle_button(ev >> 4);
	break;

      case EV_SENSOR_CLOCK:
        open_monitoring_window();
        break;

      case EV_MONITORING_CLOCK:
        close_monitoring_window();
        break;

      case EV_SLIDESHOW_CLOCK:
        advance_slideshow();
        break;

#ifdef SNAPPY_READ_NOISE
      case EV_SOUND_SAMPLE:
        record_noise(ev >> 4);
        break;
#endif

      default:
	LOG("Unknown event: %" PRIu32, ev);
	break;
      }
    } else {
      /* WHAT TO DO HERE?  We timed out or there was some bizarre error? */
    }
  }
}

static void panic(const char* msg) {
  LOG("PANIC: %s", msg);
#ifdef SNAPPY_OLED
  oled_show_text("PANIC: %s", msg);
#endif
  for(;;) {}
}

static struct timeval button_down; /* Time of button press */
static bool was_pressed = false;   /*   if this is true */

static void handle_button(uint32_t state) {
  /* Experimentation suggests that it's possible to have spurious button presses of around 10K
     us, when the finger nail sort of touches the edge of the button and slides off.  A "real"
     press lasts at least 100K us. */
  LOG("BUTTON: %" PRIu32, state);
  if (!state && was_pressed) {
    struct timeval now;
    gettimeofday(&now, NULL);
    uint64_t t = ((uint64_t)now.tv_sec * 1000000 + (uint64_t)now.tv_usec) -
      ((uint64_t)button_down.tv_sec * 1000000 + (uint64_t)button_down.tv_usec);
    LOG("  Pressed for %" PRIu64 "us", t);
    if (t < 1000000) {
      show_debug = !show_debug;
    }
  }
  was_pressed = state == 1;
  if (was_pressed) {
    gettimeofday(&button_down, NULL);
  }
}

#ifdef SNAPPY_OLED
static void advance_slideshow() {
  switch (slideshow_next) {
  case 0:
    slideshow_next++;
    oled_splash_screen();
    break;
    /* FALLTHROUGH */
  case 1:
    slideshow_next++;
    if (sensor.have_temperature) {
      oled_show_text("Temperature\n\n%.1f C", sensor.temperature);
      break;
    }
    /* FALLTHROUGH */
  case 2:
    slideshow_next++;
    if (sensor.have_humidity) {
      oled_show_text("Humidity\n\n%.1f %%", sensor.humidity);
      break;
    }
    /* FALLTHROUGH */
  case 3:
    slideshow_next++;
    if (sensor.have_atmospheric_pressure) {
      oled_show_text("Pressure\n\n%u hPa", sensor.atmospheric_pressure);
      break;
    }
    /* FALLTHROUGH */
  case 4:
    slideshow_next++;
    if (sensor.have_uv_intensity) {
      oled_show_text("UV index\n\n%d", (int)roundf(sensor.uv_intensity));
      break;
    }
    /* FALLTHROUGH */
  case 5:
    slideshow_next++;
    if (sensor.have_luminous_intensity) {
      oled_show_text("Light\n\n%.1f lux", sensor.luminous_intensity);
      break;
    }
    /* FALLTHROUGH */
  case 6:
    slideshow_next++;
    if (sensor.have_co2) {
      const char* co2_text;
      /* The scale is from the data sheet */
      if (sensor.co2 <= 600) {
        co2_text = "excellent";
      } else if (sensor.co2 <= 800) {
        co2_text = "good";
      } else if (sensor.co2 <= 1000) {
        co2_text = "adequate";
      } else if (sensor.co2 <= 1500) {
        co2_text = "bad";
      } else {
        co2_text = "terrible";
      };
      oled_show_text("CO_2\n\n%uppm - %s", sensor.co2, co2_text);
      break;
    }
    /* FALLTHROUGH */
  case 7:
    slideshow_next++;
    if (sensor.have_tvoc) {
      const char* tvoc_text;
      /* The scale is partly from the data sheet */
      if (sensor.tvoc < 50) {
        tvoc_text = "good";
      } else if (sensor.tvoc < 200) {
        tvoc_text = "adequate";
      } else if (sensor.tvoc < 750) {
        tvoc_text = "not great";
      } else if (sensor.tvoc < 6000) {
        tvoc_text = "bad";
      } else {
        tvoc_text = "dangerous";
      }
      oled_show_text("Volatile organics\n\n%uppb - %s", sensor.tvoc, tvoc_text);
      break;
    }
    /* FALLTHROUGH */
  case 8:
    slideshow_next++;
    if (sensor.have_aqi) {
      /* The scale is from the data sheet */
      static const char* aqi_text[] = {
        "",
        "excellent",
        "good",
        "adequate",
        "bad",
        "terrible" };
      oled_show_text("Air quality index\n\n%d - %s", sensor.aqi, aqi_text[sensor.aqi]);
      break;
    }
    /* FALLTHROUGH */
  case 9:
    slideshow_next++;
#ifdef SNAPPY_READ_MOTION
    oled_show_text("Movement\n\n%s", sensor.motion ? "Yes" : "No");
    break;
#else
    /* FALLTHROUGH */
#endif
  case 10:
    slideshow_next++;
#ifdef SNAPPY_READ_SOUND
    if (have_sound_level) {
      /* The scale is made-up */
      static const char* sound_text[] = {
        "",
        "eerie",
        "quiet",
        "normal",
        "bad",
        "runway?" };
      oled_show_text("Sound level\n\n%d - %s", sensor.sound_level, sound_text[sensor.sound_level]);
      break;
    }
#endif
    /* FALLTHROUGH */
  case 11:
    slideshow_next++;
    if (show_debug) {
      char buf[128];
      *buf = 0;
#ifdef SNAPPY_I2C_SEN0514
      if (have_sen0514) {
        dfrobot_sen0514_status_t stat;
        if (dfrobot_sen0514_get_sensor_status(&sen0514, &stat)) {
          sprintf(buf + strlen(buf), "A=%d %c ", (int)stat, have_calibrated_sen0514 ? 'y' : 'n');
        } else {
          sprintf(buf + strlen(buf), "A=- %c ", have_calibrated_sen0514 ? 'y' : 'n');
        }
      }
#endif
      oled_show_text(buf);
      break;
    }
    /* FALLTHROUGH */
  default:
    slideshow_next = 0;
    break;
  }
}
#endif  /* SNAPPY_OLED */

#ifdef SNAPPY_LOGGING
void snappy_log(const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  vprintf(fmt, args);
  va_end(args);
  if (fmt[strlen(fmt)-1] != '\n') {
    putchar('\n');
  }
}
#endif


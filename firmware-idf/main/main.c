/* -*- fill-column: 100; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* SnappySense firmware code based only on FreeRTOS, with esp32-idf at the device interface level.
   No Arduino. */

#include "main.h"

#include <inttypes.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>

#include "device.h"
#include "sound_player.h"
#include "sound_sampler.h"
#include "oled.h"
#include "slideshow.h"
#include "sensor.h"

#ifdef SNAPPY_LOW_POWER
# include "esp_pm.h"
# include "esp_sleep.h"
# include "driver/gpio.h"
#endif

#ifdef SNAPPY_SOUND_EFFECTS
/* Generated by the util/music-compiler program (see repo root) */
/* StarWars */
const struct tone notes_5577006791947779410[] = {{1109,197},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,1183},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,789},{440,1578},};
const struct music melody = { 40, notes_5577006791947779410 };
#endif

typedef struct {
  snappy_event_t code;
  union {
    int   ival;           /* For eg MEMS reading */
    char* s;              /* For EV_MESSAGE, non-NULL heap-allocated NUL-terminated */
    sensor_state_t* data; /* For EV_MONITOR_DATA, non-NULL heap-allocated */
  };
} event_t;
   
/* The global event queue for the main loop is used for virtually all communciation among the
   various "tasks" in the system.  */

static QueueHandle_t/*<event_t>*/ event_queue;

static void init_queue() {
  event_queue = xQueueCreate(100, sizeof(event_t));
  if (event_queue == NULL) {
    panic("Could not create event queue");
  }
}

void put_main_event(snappy_event_t code) {
  assert(code != EV_MESSAGE);
  event_t ev = { .code = code };
  xQueueSend(event_queue, &ev, 0); /* 0 because called from timer callbacks */
}

void put_main_event_with_ival(snappy_event_t code, int ival) {
  assert(code != EV_MESSAGE);
  event_t ev = { .code = code, .ival = ival };
  xQueueSend(event_queue, &ev, 0); /* 0 because called from timer callbacks */
}

void put_main_event_with_data(snappy_event_t code, sensor_state_t* data) {
  assert(code == EV_MONITOR_DATA);
  event_t ev = { .code = code, .data = data };
  xQueueSend(event_queue, &ev, 0); /* 0 because called from timer callbacks */
}

void put_main_event_with_string(snappy_event_t code, const char* s) {
  assert(code == EV_MESSAGE);
  char* t = strdup(s);
  if (t == NULL) {
    panic("OOM");
  }
  event_t ev = { .code = code, .s = t };
  xQueueSend(event_queue, &ev, 0); /* 0 because called from timer callbacks */
}

void put_main_event_from_isr(snappy_event_t code) {
  assert(code != EV_MESSAGE);
  event_t ev = { .code = code };
  xQueueSendFromISR(event_queue, &ev, NULL);
}

/* The master timer is used to move the event loop through its major stages. */

static TimerHandle_t master_timer;

static void master_timer_handler(TimerHandle_t t) {
  put_main_event((snappy_event_t)(uint32_t)pvTimerGetTimerID(t));
}

static void init_master_timer() {
  master_timer = xTimerCreate("main",
                              1,
                              pdFALSE,
                              NULL,
                              master_timer_handler);
}

static void set_master_timer(unsigned timeout_ms, snappy_event_t payload) {
  vTimerSetTimerID(master_timer, (void*)payload);
  xTimerChangePeriod(master_timer, pdMS_TO_TICKS(timeout_ms), portMAX_DELAY);
}

static void cancel_master_timer() {
  xTimerStop(master_timer, portMAX_DELAY);
}


static void snappy_main() NO_RETURN;
static void bring_up_peripherals();
static void shut_down_peripherals();

#ifdef SNAPPY_LOW_POWER
static esp_pm_config_t pmconf;
# ifdef SNAPPY_LIGHT_SLEEP
static void enable_light_sleep();
# endif
#endif

void app_main(void) {

  /* Create resources (mostly timers) for various things but do not start anything running yet. */

  /* Shared message queue */
  init_queue();

  if (!sensor_init()) {
    LOG("Could not start sensor subsystem");
    panic("Sensor fail");
  }

#ifdef SNAPPY_READ_NOISE
  if (!sound_sampler_begin()) {
    LOG("Unable to initialize the sampler task");
  }
#endif

#ifdef SNAPPY_SOUND_EFFECTS
  if (!sound_effects_begin()) {
    LOG("Unable to initialize the sound player task");
  }
#endif

#ifdef SNAPPY_SLIDESHOW
  if (!slideshow_begin()) {
    LOG("Could not start slideshow");
    panic("Slideshow fail");
  }
#endif

  /* Set up interrupt handling, interrupts will be hooked by and by. */
  install_interrupts();

  /* Set up buttons but do not make them send events yet. */
  initialize_onboard_buttons();

#ifdef SNAPPY_LOW_POWER
  /* For low-power use you need to configure with:
     - CONFIG_PM_ENABLE and CONFIG_PM_DFS_INIT_AUTO to enable dynamic frequency scaling
     - CONFIG_FREERTOS_USE_TICKLESS_IDLE to allow light-sleep mode when the system is idle
     Actually enabling tickless idle without turning on light sleep is a savings in itself.
  */
  esp_pm_get_configuration(&pmconf);
  LOG("Conf: %d %d %d", pmconf.max_freq_mhz, pmconf.min_freq_mhz, pmconf.light_sleep_enable);

  /* Light sleep is enabled when we're in the sleep window for reasons described in that code. */
#endif

  /* Turn on the regulator and initialize devices that get power from it. */
  bring_up_peripherals();

  /* We're up. */
  LOG("Snappysense active!");
#ifdef SNAPPY_OLED
  oled_show_text("SnappySense v1.1\nKnowIt ObjectNet\n2023-04-04 / IDF");
#endif

  /* Buttons will now send events */
  enable_onboard_buttons();

  snappy_main();
}

static bool slideshow_mode = true;

static void button_down() {
}

static void button_up() {
  /* FIXME - primitive */
  put_main_event(EV_BUTTON_PRESS);
}

static int monitoring_window_s() {
  return 60;
}

static int slideshow_mode_sleep_s() {
  return 60;
}

static int monitoring_mode_sleep_s() {
  return 2*60;
}

static void snappy_main() {
  LOG("Snappysense running!");

  /* True iff the main loop is in the monitoring window, between MONITOR_START and MONITOR_STOP. */
  bool in_monitoring_window = false;

  /* True when the peripherals have been powered down and we are between SLEEP_START and
     POST_SLEEP. */
  bool in_sleep_window = false;

  /* This starts out the same as slideshow_mode but can be changed by a button press, and is acted
     upon at a specific point in the state machine. */
  bool slideshow_next_mode = slideshow_mode;

  /* This is used to improve the UX.  It shortens the comm window the first time around and skips
     the relaxation / sleep before we read the sensors. */
  bool first_time = true;

  /* This is used to improve the UX.  It is set by the button press handler when the button is used
     to wake the device, and causes the next comm window to ignore the guard against uploading too
     often, in other words, the assumption is that by waking the device the user wants to see any
     pending data as soon as possible.  It is reset again when the device goes to sleep. */
  bool explicitly_awoken = false;

  (void)in_monitoring_window;
  (void)explicitly_awoken;

  /* The master timer drives the logic of the event loop. */
  init_master_timer();

  /* The slideshow task starts whether we're in slideshow mode or not, since slideshow mode only
     affects what happens between communication and monitoring, and for how long.  The first thing
     the task does is show the splash screen.  But give the user a little time to read the version
     message. */
  vTaskDelay(pdMS_TO_TICKS(4000));
  put_main_event(EV_SLIDESHOW_START);

  /* Start the main task. */
  put_main_event(EV_START_CYCLE);

  /* Process events forever.

     This is mainly a state machine with a cycle of sleep-monitoring-reporting-sleep-... states.
     Within the monitoring and reporting states there may be minor cycles.  Right now the machine is
     driven by a clock that starts the monitoring state and there is no reporting state, but this
     will change.
   
     Overlapping that state machine is one that drives the slide show, if enabled.  The two state
     machines are independent but are handled by the same switch for practical reasons.  Thus some
     display work can happen during monitoring, but this should not adversely affect anything.
   
     Finally, some events can interrupt the state machine.  PIR interrupts are seen during
     monitoring and are simply recorded.  Button interrupts are seen anytime and are currently
     ignored but may cause the device operation to change. */

  for(;;) {
    event_t ev;
    if(xQueueReceive(event_queue, &ev, portMAX_DELAY)) {
      switch (ev.code) {

      /*********************************************************************************/
      /* Main task */

      case EV_START_CYCLE:
        /* TODO: No communication work yet so just go into sleep */
        put_main_event(EV_SLEEP_START);
        break;

      case EV_SLEEP_START:
        explicitly_awoken = false;
        /* Figure out what mode we're in.  In monitoring mode, we turn off the screen and go
           into low-power state.  In slideshow mode, we continue on as we were, for a while. */
        if (first_time) {
          put_main_event(EV_POST_SLEEP);
        } else {
          slideshow_mode = slideshow_next_mode;
          LOG("New mode: %s\n", slideshow_mode ? "slideshow" : "monitoring");
          if (slideshow_mode) {
            set_master_timer(slideshow_mode_sleep_s() * 1000, EV_POST_SLEEP);
          } else {
            put_main_event(EV_SLIDESHOW_STOP);
            set_master_timer(monitoring_mode_sleep_s() * 1000, EV_POST_SLEEP);
            LOG("Nap time.  Sleep mode activated.\n");
            shut_down_peripherals();
            in_sleep_window = true;
#ifdef SNAPPY_LIGHT_SLEEP
            // enable_light_sleep() will allow the system to go into light sleep mode when nothing
            // is going on.  But it's not yet clear how we handle getting out of that and moving to
            // EV_POST_SLEEP.  It's possible we can install hooks?  Certainly when the timer fires
            // we do come out and the timer will move us to EV_POST_SLEEP.  So it's all about the
            // button press.
            enable_light_sleep();
#endif
          }
        }
        break;

      case EV_POST_SLEEP:
        if (in_sleep_window) {
          /* We can come to POST_SLEEP from either the timeout or from a button press. */
          cancel_master_timer();
          bring_up_peripherals();
          LOG("Is anyone there?\n");
          in_sleep_window = false;
          put_main_event(EV_SLIDESHOW_RESET);
          put_main_event(EV_SLIDESHOW_START);
        }
        put_main_event(EV_MONITOR_START);
        first_time = false;
        break;

      case EV_MONITOR_START:
        LOG("Monitoring window opens\n");
        in_monitoring_window = true;
        monitoring_start();
        set_master_timer(monitoring_window_s() * 1000, EV_MONITOR_STOP);
        break;

      case EV_MONITOR_STOP:
        monitoring_stop();
        put_main_event(EV_START_CYCLE);
        LOG("Monitoring window closes\n");
        in_monitoring_window = false;
        break;

      /* Events delivered to the main task */

      case EV_MONITOR_DATA: {
        LOG("Monitor data received\n");
        // monitor data arrived after closing the monitoring window
        // slideshow_new_data takes over the ownership of the new_data.
        assert(ev.data != NULL);
#ifdef SNAPPY_SLIDESHOW
        slideshow_new_data(ev.data);
#endif
        break;
      }

      case EV_BUTTON_PRESS:
        if (in_sleep_window) {
          // Wake up and move the state machine along.  POST_SLEEP will cancel any pending timeout.
          explicitly_awoken = true;
          put_main_event(EV_POST_SLEEP);
          put_main_event_with_string(EV_MESSAGE,
                                     slideshow_mode ? "Slideshow mode" : "Monitoring mode");
          break;
        }

        slideshow_next_mode = !slideshow_next_mode;
        put_main_event(EV_SLIDESHOW_RESET);
        put_main_event_with_string(EV_MESSAGE,
                                   slideshow_next_mode ? "Slideshow mode" : "Monitoring mode");
        put_main_event(EV_SLIDESHOW_START);
        break;

      /*********************************************************************************/
      /* Monitor task */

      case EV_MONITOR_WARMUP:
        monitoring_warmup();
        break;

      /*********************************************************************************/
      /* Display and slideshow task.  The RESET/START/STOP events are here to ensure that operations
         are performed in the correct order.  Code that posts them can be sure that they are
         executed after any operations that may already be in the queue. */

      case EV_MESSAGE:
#ifdef SNAPPY_SLIDESHOW
        slideshow_show_message_once(ev.s);
#endif
        break;

      case EV_SLIDESHOW_RESET:
#ifdef SNAPPY_SLIDESHOW
        slideshow_reset();
#endif
        break;

      case EV_SLIDESHOW_START:
#ifdef SNAPPY_SLIDESHOW
        slideshow_start();
#endif
        break;

      case EV_SLIDESHOW_STOP:
#ifdef SNAPPY_SLIDESHOW
        slideshow_stop();
#endif
        break;

      case EV_SLIDESHOW_WORK:
#ifdef SNAPPY_SLIDESHOW
        slideshow_next();
#endif
        break;

      /*********************************************************************************/
      /* Button monitor task */

      case EV_BUTTON_DOWN:
        button_down();
        break;

      case EV_BUTTON_UP:
        button_up();
        break;

      /*********************************************************************************/
      /* Sensor monitor task */

      case EV_MOTION_DETECTED:
#ifdef SNAPPY_READ_MOTION
        record_motion();
#endif
        break;

      case EV_MEMS_WORK:
#ifdef SNAPPY_READ_NOISE
        sample_noise();
#endif
        break;

      case EV_MEMS_SAMPLE:
#ifdef SNAPPY_READ_NOISE
        record_noise(ev.ival);
#endif
        break;

      default:
        panic("Unknown event");
      }
    } else {
      /* Timeout - just try again */
    }
  }
}

void panic(const char* msg) {
  LOG("PANIC: %s", msg);
#ifdef SNAPPY_OLED
  oled_show_text("PANIC: %s", msg);
#endif
  for(;;) {}
}

#ifdef SNAPPY_LOGGING
void snappy_log(const char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  vprintf(fmt, args);
  va_end(args);
  if (fmt[strlen(fmt)-1] != '\n') {
    putchar('\n');
  }
}
#endif

#ifdef SNAPPY_LIGHT_SLEEP

// Also see comment above at EV_SLEEP_START

# error "Not complete."

static void enable_light_sleep() {

  // Basically if we got here *not* from the timer it was from the button
  // But how do we get into EV_POST_SLEEP?
  // esp_sleep_get_wakeup_cause() can get us the wakeup reason, if there was one
  // Is there an ISR for the button?
  // Is it just that we return from esp_light_sleep_start()?  I guess so

  // There is also gpio_wakeup_disable() and we must call that but it does *not* change
  // the state of the gpio, that must be done separately.

  /* FIXME: Abstraction leak */
  /* FIXME: Unclear if this plays nice with the button logic.  I think it means we'll wake up when
     the button is pressed but it's not obvious that the event loop logic will see the button press,
     only the release. */
  /* FIXME: This actually doesn't work well at all.  It resets the meaning of the gpio, so we don't
     get button presses at all through the normal interrupt path.  It is possible this is something
     we can do as the state machine enters the sleep state instead? */
  if (gpio_wakeup_enable(25, GPIO_INTR_HIGH_LEVEL) == ESP_OK) { /* BTN1 */
    esp_sleep_enable_gpio_wakeup();

    pmconf.light_sleep_enable = 1;
    esp_err_t err;
    if ((err = esp_pm_configure(&pmconf)) != ESP_OK) {
      LOG("Failed to set light sleep mode: %d", (int)err);
    }
  } else {
    LOG("Failed to set wakeup source");
  }

}
#endif

static void bring_up_peripherals() {
  /* Bring the power line up and wait until it stabilizes */
  enable_regulator();

#ifdef SNAPPY_I2C
  if (!enable_i2c()) {
    panic("i2c initialization failed; nothing will work");
  }
#endif

#ifdef SNAPPY_I2C_SSD1306
  /* Display */
  if (!initialize_i2c_ssd1306()) {
    LOG("OLED device inoperable");
  }
#endif
#ifdef SNAPPY_OLED
  oled_clear_screen();
#endif

#ifdef SNAPPY_I2C_SEN0500
  /* Environment sensor */
  if (!initialize_i2c_sen0500()) {
    LOG("Environment device inoperable");
  }
#endif

#ifdef SNAPPY_I2C_SEN0514
  /* Air/gas sensor */
  if (!initialize_i2c_sen0514()) {
    LOG("Air/gas device inoperable");
  }
#endif

#ifdef SNAPPY_GPIO_SEN0171
  /* Movement sensor */
  if (!initialize_gpio_sen0171()) {
    LOG("Movement device inoperable");
  }
#endif

#ifdef SNAPPY_ADC_SEN0487
  /* Sound sensor - not currently in use */
# error "Work needed"
  /* FIXME: The ADC is initialized on startup, but there might not be anything to do for the MEMS
     device per se */
  if (!initialize_adc_sen0487()) {
    LOG("Sound device inoperable");
  }
#endif

#ifdef SNAPPY_ESP32_LEDC_PIEZO
  /* Buzzer - not currently in use */
# error "Work needed"
  /* FIXME: The DAC is initialized on startup or by the ledc system but there might not be anything
     to do for the piezo here per se */
  if (!initialize_esp32_ledc_piezo()) {
    LOG("Piezo device inoperable");
  }
#endif
}

static void shut_down_peripherals() {
#ifdef SNAPPY_GPIO_SEN0171
  disable_gpio_sen0171();
#endif
  /* None of the other devices have shutdown actions, their init functions are idempotent. */
#ifdef SNAPPY_I2C
  if (!disable_i2c()) {
    LOG("Failed to shut down I2C properly");
  }
#endif
  disable_regulator();
}

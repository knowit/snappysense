/* -*- fill-column: 100; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/* SnappySense firmware code based on the ESP32-IDF + FreeRTOS framework only (no Arduino). */

#include "main.h"

#include <inttypes.h>
#include <math.h>
#include <sys/time.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

#include "device.h"
#include "piezo.h"
#include "resources.h"

/* Parameters */
#define MONITORING_WINDOW_S 10
#define MONITORING_INTERVAL_S 15
#define NEXT_SLIDE_INTERVAL_S 4

/* Generated by the music-compiler program (see repo root) */
/* StarWars */
const struct tone notes_5577006791947779410[] = {{1109,197},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,1183},{740,197},{740,197},{740,197},{988,1183},{1480,1183},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1109,197},{1976,1183},{1480,591},{1319,197},{1245,197},{1319,197},{1109,789},{440,1578},};
const struct music melody = { 40, notes_5577006791947779410 };

/* Queues and clocks */
static QueueHandle_t evt_queue = NULL;
static TimerHandle_t sensor_clock = NULL;
static TimerHandle_t slideshow_clock = NULL;
static TimerHandle_t monitoring_clock = NULL;

static void clock_callback(TimerHandle_t t) {
  uint32_t ev = EV_NONE;
  if (t == sensor_clock) {
    ev = EV_SENSOR_CLOCK;
  } else if (t == slideshow_clock) {
    ev = EV_SLIDESHOW_CLOCK;
  } else if (t == monitoring_clock) {
    ev = EV_MONITORING_CLOCK;
  }
  xQueueSend(evt_queue, &ev, portMAX_DELAY);
}

/* Sensor state */
static bool have_temperature = false;
static float temperature;
static bool have_humidity = false;
static float humidity;
static bool have_atmospheric_pressure = false;
static unsigned atmospheric_pressure;
static bool have_uv_intensity = false;
static float uv_intensity;
static bool have_luminous_intensity = false;
static float luminous_intensity;
static bool have_co2 = false;
static unsigned co2;
static bool motion = false;

static void advance_slideshow();
static void show_text(const char* fmt, ...);
static void open_monitoring_window();
static void close_monitoring_window();
static void record_motion();

void app_main(void)
{
  /* Bring the power line up and wait until it stabilizes */
  power_up_peripherals();

  /* Queue of events from clocks and ISRs to the main task */
  evt_queue = xQueueCreate(10, sizeof(uint32_t));
  install_interrupts(evt_queue);

  /* Initialize peripherals */

  initialize_onboard_buttons();

#ifdef SNAPPY_GPIO_SEN0171
  /* Movement sensor */
  initialize_gpio_sen0171();
#endif

#ifdef SNAPPY_I2C
  initialize_i2c();
#endif

  /* TODO: SNAPPY_ADC_SEN0487 microphone */

#ifdef SNAPPY_I2C_SEN0500
  /* Environment sensor */
  initialize_i2c_sen0500();
#endif

#ifdef SNAPPY_I2C_SEN0514
  /* Air/gas sensor */
  initialize_i2c_sen0514();
#endif

#ifdef SNAPPY_I2C_SSD1306
  /* Display */
  initialize_i2c_ssd1306();
#endif

  /* Create a clock tick used to drive device readings */
  /* TODO: Should we have this instead separate windows by this interval and not
     just blindly start new monitoring this often? */
  sensor_clock = xTimerCreate("sensor", pdMS_TO_TICKS(MONITORING_INTERVAL_S*1000),
                              /* restart= */ pdTRUE,
                              NULL, clock_callback);
  xTimerStart(sensor_clock, portMAX_DELAY);

  /* This one-shot timer is started when the monitoring window opens and signals the
     close of the window. */
  monitoring_clock = xTimerCreate("monitor", pdMS_TO_TICKS(MONITORING_WINDOW_S*1000),
                                  /* restart= */ pdFALSE,
                                  NULL, clock_callback);

#ifdef SNAPPY_I2C_SSD1306
  /* Create a clock tick used to drive the slideshow, independent of monitoring. */
  if (ssd1306) {
    slideshow_clock = xTimerCreate("slideshow", pdMS_TO_TICKS(NEXT_SLIDE_INTERVAL_S*1000),
                                   /* restart= */ pdTRUE,
                                   NULL, clock_callback);
    xTimerStart(slideshow_clock, portMAX_DELAY);
  }
#endif

  /* And we are up! */
  LOG("Snappysense running!\n");
  show_text("SnappySense v1.1\nESP32-IDF firmware\nObjectNet 2023");
  //  play_song(&melody);

  /* Process events forever */
  struct timeval button_down; /* Time of button press */
  bool was_pressed = false;   /*   if this is true */

  for(;;) {
    uint32_t ev;
    if(xQueueReceive(evt_queue, &ev, portMAX_DELAY)) {
      switch (ev & 15) {
      case EV_PIR:
        record_motion();
	break;

      case EV_BTN1: {
	/* Experimentation suggests that it's possible to have spurious button presses of around 10K
	   us, when the finger nail sort of touches the edge of the button and slides off.  A "real"
	   press lasts at least 100K us. */
	uint32_t state = ev >> 4;
	LOG("BUTTON: %" PRIu32 "\n", state);
	if (!state && was_pressed) {
	  struct timeval now;
	  gettimeofday(&now, NULL);
	  uint64_t t = ((uint64_t)now.tv_sec * 1000000 + (uint64_t)now.tv_usec) -
	    ((uint64_t)button_down.tv_sec * 1000000 + (uint64_t)button_down.tv_usec);
	  LOG("  Pressed for %" PRIu64 "us\n", t);
	}
	was_pressed = state == 1;
	if (was_pressed) {
	  gettimeofday(&button_down, NULL);
	}
	break;
      }

      case EV_SENSOR_CLOCK:
        open_monitoring_window();
        break;

      case EV_MONITORING_CLOCK:
        close_monitoring_window();
        break;

      case EV_SLIDESHOW_CLOCK:
        advance_slideshow();
        break;

      default:
	LOG("Unknown event: %" PRIu32 "\n", ev);
	break;
      }
    } else {
      /* WHAT TO DO HERE?  We timed out or there was some bizarre error? */
    }
  }
}

void panic(const char* msg) {
  LOG("PANIC: %s\n", msg);
  show_text("PANIC: %s", msg);
  for(;;) {}
}

static void open_monitoring_window() {
  LOG("Monitoring window opens\n");
#ifdef SNAPPY_I2C_SEN0500
  /* Environment sensor.  These we read instantaneously.  It might make sense to read multiple
   * times and average or otherwise integrate; TBD.
   */
  if (have_sen0500) {
    have_temperature =
      dfrobot_sen0500_get_temperature(&sen0500, DFROBOT_SEN0500_TEMP_C, &temperature) &&
      temperature != -45.0;
    if (have_temperature) {
      LOG("Temperature = %.2f\n", temperature);
    }
    have_humidity =
      dfrobot_sen0500_get_humidity(&sen0500, &humidity) &&
      humidity != 0.0;
    if (have_humidity) {
      LOG("Humidity = %.2f\n", humidity);
    }
    have_atmospheric_pressure =
      dfrobot_sen0500_get_atmospheric_pressure(&sen0500, DFROBOT_SEN0500_PRESSURE_HPA,
                                               &atmospheric_pressure) &&
      atmospheric_pressure != 0;
    if (have_atmospheric_pressure) {
      LOG("Pressure = %u\n", atmospheric_pressure);
    }
    have_uv_intensity =
      dfrobot_sen0500_get_ultraviolet_intensity(&sen0500, &uv_intensity) &&
      uv_intensity != 0.0;
    if (have_uv_intensity) {
      LOG("UV intensity = %.2f\n", uv_intensity);
    }
    have_luminous_intensity =
      dfrobot_sen0500_get_luminous_intensity(&sen0500, &luminous_intensity) &&
      luminous_intensity != 0.0;
    if (have_luminous_intensity) {
      LOG("Luminous intensity = %.2f\n", luminous_intensity);
    }
  }
#endif
#ifdef SNAPPY_I2C_SEN0514
  if (have_sen0514) {
    dfrobot_sen0514_status_t stat;
    if (dfrobot_sen0514_get_sensor_status(&sen0514, &stat) &&
        stat == DFROBOT_SEN0514_NORMAL_OPERATION) {
      if (have_temperature && have_humidity) {
        if (dfrobot_sen0514_prime(&sen0514, temperature, humidity/100.0f)) {
          have_co2 =
            dfrobot_sen0514_get_co2(&sen0514, &co2) &&
            co2 > 400;
        }
      }
    }
  }
#endif
#ifdef SNAPPY_GPIO_SEN0171
  /* Motion sensor.  We enable the interrupt for the PIR while the monitoring window is open;
   * then PIR interrupts will simply be recorded higher up in the switch.
   */
  motion = false;
  enable_gpio_sen0171();
#endif
  xTimerStart(monitoring_clock, portMAX_DELAY);
}

static void record_motion() {
  LOG("Motion!\n");
  motion = true;
}

static void close_monitoring_window() {
#ifdef SNAPPY_GPIO_SEN0171
  disable_gpio_sen0171();
#endif
  LOG("Monitoring window closed\n");
}

#ifdef SNAPPY_I2C_SSD1306
static void splash_screen() {
  ssd1306_Fill(ssd1306, SSD1306_BLACK);
  ssd1306_DrawBitmap(ssd1306, 0, 1,
                     knowit_logo, KNOWIT_LOGO_WIDTH, KNOWIT_LOGO_HEIGHT,
                     SSD1306_WHITE);
  ssd1306_UpdateScreen(ssd1306);
}
#endif

static void advance_slideshow() {
  static int slideshow_next = 0;

  /* TODO: Splash screen */
  /* TODO: For the text display, use bitmaps *or* use a larger font and
     center the text and place the text on two lines, caption above
     and reading + units below */
  switch (slideshow_next) {
  case 0:
    slideshow_next++;
#ifdef SNAPPY_I2C_SSD1306
    if (ssd1306) {
      splash_screen();
      break;
    }
#endif
    /* FALLTHROUGH */
  case 1:
    slideshow_next++;
    if (have_temperature) {
      show_text("Temperature\n\n%.1f C", temperature);
      break;
    }
    /* FALLTHROUGH */
  case 2:
    slideshow_next++;
    if (have_humidity) {
      show_text("Humidity\n\n%.1f %%", humidity);
      break;
    }
    /* FALLTHROUGH */
  case 3:
    slideshow_next++;
    if (have_atmospheric_pressure) {
      show_text("Pressure\n\n%u hPa", atmospheric_pressure);
      break;
    }
    /* FALLTHROUGH */
  case 4:
    slideshow_next++;
    if (have_uv_intensity) {
      show_text("UV index\n\n%d", (int)roundf(uv_intensity));
      break;
    }
    /* FALLTHROUGH */
  case 5:
    slideshow_next++;
    if (have_luminous_intensity) {
      show_text("Light\n\n%.1f lux", luminous_intensity);
      break;
    }
    /* FALLTHROUGH */
  case 6:
    slideshow_next++;
    if (have_co2) {
      show_text("CO_2\n\n%u ppm", co2);
      break;
    }
    /* FALLTHROUGH */
  case 7:
    slideshow_next++;
#ifdef SNAPPY_GPIO_SEN0171
    show_text("Motion\n\n%s", motion ? "Yes" : "No");
    break;
#else
    /* FALLTHROUGH */
#endif
  default:
    slideshow_next = 0;
    break;
  }
}

/* Display abstractions. */
#ifdef SNAPPY_I2C_SSD1306
void show_text(const char* fmt, ...) {
  if (!ssd1306) {
    return;
  }
  va_list args;
  va_start(args, fmt);
  char buf[32*4];		/* Largest useful string for this screen and font */
  vsnprintf(buf, sizeof(buf), fmt, args);
  va_end(args);
  ssd1306_Fill(ssd1306, SSD1306_BLACK);
  char* p = buf;
  int y = 0;
  while (*p) {
    char* start = p;
    while (*p && *p != '\n') {
      p++;
    }
    if (*p) {
      *p++ = 0;
    }
    ssd1306_SetCursor(ssd1306, 0, y);
    ssd1306_WriteString(ssd1306, start, Font_7x10, SSD1306_WHITE);
    y += Font_7x10.FontHeight + 1;
  }
  ssd1306_UpdateScreen(ssd1306);
}
#else
#define show_text(...)
#endif
